Тэкс, я тут по мере возможностей свои долги перед вами разгребаю, начнём с проекта:

Проект: 
на четыре - ТГ бот "дневник"
 требования - 
   1) Возможность делать записи, о том, что сегодня произошло ( один и более раз или не делать записей вообще в этот день)
   2) возможность вывести все записи из конкретного дня

На шесть - ТГ бот планировщик задач
Требования - 
  + 1) составить список задач с дедлайнами
   +2) изменить задачи/текст задачи (например, исправить опечатку или проставить "галочку" что задача выполнена)
   +3) удалять задачи на конкретную дату
   +4) писать сколько профакапили, или сколько осталось времени до дедлайна для каждой задачи, когда пользователь просит вывести список дел

На восемь - десять 
всё из проекта для шести, плюс:
   1) дать возможность устанавливать напоминания для пользователя(и соответственно эти напоминания присылать пользователю).
    2) если для задачи сроки истекли, пролонгировать её срок на день и прислать отбивку пользователю об этом
    3*) Ваши улучшения, которые имеют некоторую технологическую сложность и потребуют какого-то взаимодействия с бд, например(но не обязательно конкретно это реализовывать, естественно), прикрутить нейронку, которая по всем текущим задачам и дедлайнам будет подсказывать пользователю стоит ли брать ещё одну задачку или надо сначала остальные завершить...или дедлайн у новой подвинуть например. 


P.S. На оценку 4 и 6 достаточно будет использовать MongoDB в качестве хранилища данных, на оценку 8 будет необходимо использовать брокер сообщений(не обязательно "большой" типа rabbitMQ, достаточно будет и, например, Redis, который рассмотрим после mongoDB) и очередь задач (например  Celery в  python)
P.S.2 - проект опять достаточно большой, поэтому можно делать в паре, не забывайте, что не обязательно всё в одном приложении делать(для 4-ки можно и не париться с сервисами, там лишь бы работало всё), можно несколько сервисов напилить и их взаимодействие. Ну и откладывать, думаю многие поняли, что в долгий ящик не стоит и делать в последнюю ночь перед защитой не стоит) 
P.S.3 - мини плюшка для вас, оба проекта с нашего курса можно(да и нужно) выложить на гитхаб(например), что даст вам в будущем некоторые преимущества: 1) не потеряете код, 2) можете в случае чего козырнуть знаниями, 3) реальное доказательство того, что вы умеете и обладаете навыками/знаниями в некотором стеке, что дает возможность легче пройти собес, если правильно применить этот факт.

#TODO:
Поместить все в докер, чтобы не мучиться с запуском контейнеров

Сценарий 2: Выполнить задачу через час
Следующая задача - пользователь создал статью и хочет опубликовать её через один час. Настало время узнать об аргументах, которые принимает apply_async.

Вариантов здесь - два. Самый простой - аргумент countdown - в переводе "обратный отсчёт". Он позволяет задать время в секундах, через которое задача станет доступна для выполнения. Как раз то, что нам нужно!

from datetime import datetime

@app.task
def publish_article(arg1, arg2):
    print(f"Publish time: {datetime.now()}")

publish_article_after = 60 * 60 # 60 минут
result = publish_article.apply_async(args=[article_id], countdown=publish_article_after)


Здесь есть две важных детали:

при использовании Redis отложенные с помощью eta задачи столкнутся с той же проблемой, что и countdown из-за VISIBILITY_TIMEOUT.

eta - это не точное время, в которое будет выполнена задача. Указывая время, мы говорим Celery - "задача должна быть выполнена не раньше этого времени". Как только это время наступит - задача будет выполнена в порядке очереди и будет зависеть от количества задач в очереди.

Вот пример:

from datetime import datetime

# Получим время для примера. В нормальной ситуации - 
# нам придет аргумент с временем публикации
now = datetime.now()
tomorrow = now + timedelta(days=1)

publish_article_datetime = datetime(tomorrow.year, tomorrow.month, tomorrow.day, 12, 0, 0)

result = publish_article.apply_async(args=["some_value"], eta=publish_article_datetime)